# `SysY`符号表

[toc]

> ### `SysY`语言定义
>
> 1. 每个源文件中**有且仅有**一个名为`main`的主函数定义
> 2. 源文件可以包含若干**全局变量声明**、**常量声明**和**其他函数定义**
> 3. 支持`int`类型和元素为`int`类型且**按行优先存储**的多维数组类型。其中`int`型整数为**32位有符号数**，`const`修饰符用于声明常量
>
> #### 函数
>
> 函数可以带参数/不带参数，参数的类型可以是`int`或者数组类型。函数可以返回`int`类型或不返回值（声明为`void`类型）。
>
> 参数为`int`型时，按值传递；参数为数组时，传递数组起始地址，并且形参只有第一维的长度可以空缺。
>
> 函数体由若干变量声明和语句组成。
>
> #### 变量/常量声明
>
> 可以在一个变量/常量声明语句中声明多个变量或常量，声明时可以带初始化表达式。
>
> 所有变量/常量要求**先定义再使用**。在**函数外**声明的为**全局变量/常量**，**函数内**则为**局部变量/常量**。
>
> #### 语句
>
> 语句包括赋值、表达式（可以为空）、语句块、`if`、`while`、`break`、`continue`、`return`语句。
>
> 语句块中可以包含若干变量声明和语句。
>
> #### 表达式
>
> 支持基本的算术运算`+ - * / %`、关系运算`== != < > <= >=`和逻辑运算`! && ||`。
>
> 非0表示真，0表示假。而关系运算或逻辑运算的结果用1表示真，0表示假。
>
> ### `SysY`语言语义约束
>
> 因为修改了文法，所以此部分也有相应修改。
>
> #### `CompUnit`
>
> ```
> CompUnit -> Decl
> 		  | FuncDef
> 		  | CompUnit Decl
> 		  | CompUnit FuncDef
> Decl -> ConstDecl | VarDecl
> ```
>
> 1. 一个`SysY`程序由单个文件组成，必须存在且仅存在一个标识为`main`，无参数、返回类型为`int`的`FuncDef`。`main`函数是程序的入口点，`main`函数的**返回结果需要输出**。
> 2. **顶层**变量/常量声明语句（对应`Decl`）、函数定义（对应`FuncDef`）都不可以重复定义同名标识符（`Ident`），即便标识符的类型不同也不允许。
> 3. `CompUnit`的变量/常量/函数声明的作用域从该声明处开始到文件结尾。
>
> #### `ConstDef`
>
> ```
> ConstDef -> Ident '=' ConstInitVal
> 		  | Ident ConstArraySubSeq '=' ConstInitVal
> ```
>
> 1. `ConstDef`用于定义符号常量。
> 2. 数组维度和各维长度的定义不存在时，表示定义单个变量，`=`右边必须是单个数值。
> 3. 数组维度和各维长度的定义存在时，表示定义数组，表示各维长度的`ConstExp`都必须能在编译时求值到**非负整数**。
>
> #### `VarDef`
>
> ```
> VarDef -> Ident
> 		| Ident ConstArraySubSeq
> 		| Ident '=' InitVal
> 		| Ident ConstArraySubSeq '=' InitVal
> ```
>
> 1. `VarDef`用于定义变量，当不含有`=`和初值时，其初值未定义。
> 2. `VarDef`的数组维度和长度定义不存在时，表示定义单个变量，存在时和`ConstDef`类似，表示定义多维数组。（参加`ConstDef`的第二点。
> 3. `VarDef`含有`=`和初始值时，右边的`InitVal`和`CosntInitVal`的结构要求相同，惟一的不同是`ConstInitVal`中的表达式是`ConstExp`常量表达式，而`InitVal`中的表达式可以是当前上下文合法的任何`Exp`。
> 4. `VarDef`中表示各维长度的`ConstExp`必须是能够求值到非负整数，但`InitVal`中的初始值为`Exp`，其中可以引用变量。
>
> #### `(Const)InitVal`
>
> 1. **全局变量声明中指定的初值表达式必须是常量表达式**
>
> 2. 常量或变量声明中指定的初值要与该常量或变量的类型一致，如下形式的`VarDef / ConstDef`不满足语义约束：
>
>    ```c
>    a[4] = 4
>    a[2] = {{1, 2}, 3}
>    a = {1, 2, 3}
>    ```
>
> 3. 未显式初始化的**局部变量，值是不确定的**；未显式初始化的**全局变量，其（元素）的值均被初始化为0**。
>
> #### `FuncFParam`
>
> 1. `FuncFParam`定义一个函数的一个形式参数。
> 2. 当`FuncFParam`为数组定义时，其第一维的长度省去（用方括号`[]`表示），而后面的各维则需要用表达式指明长度，长度是常量。
> 3. 函数实参的语法是`Exp`，对于`int`类型的参数，遵循按值传递；对于数组类型的参数，形参接收的是实参的地址。
> 4. 对于多维数组，可传递其中的一部分到形参数组中。例如，若`int a[4][3]`，则`a[1]`是包含三个元素的一维数组，`a[1]`可以作为参数传递给类型为`int[]`的形参。
>
> #### `FuncDef`
>
> ```
> FuncDef -> BType Ident '(' ')' Block
> 		 | BType Ident '(' FuncFParams ')' Block
> ```
>
> 1. `BType`表示函数返回类型
>    1. 当返回类型为`int`时，所有分支都应当含带有`Exp`的`return`语句，不含`return`语句的分支返回值未定义
>    2. 当返回类型为`void`时，函数内只能出现不带返回值的`return`语句
> 2. 形参列表对于函数体相当于变量声明
> 3. 函数可以带参数/不带参数，参数的类型可以是`int`或者元素为`int`的多维数组。当是后者时，形参只有第一维的长度可以空缺，其余各维长度均必须是常量
> 4. 参数为`int`型时，按值传递；参数为数组时，传递数组起始地址，通过地址间接访问实参数组中的元素
>
> #### `Block`
>
> 1. `Block`表示语句块，语句块会**创建作用域**，语句块内变量的生存期在该语句块内
> 2. 语句块内可以定义与语句块外**同名**的变量/常量，其作用域从定义处到该语句块尾，它**隐藏**语句块外的同名变量/常量
>
> #### `Stmt`
>
> 1. `Stmt`中的`if`语句遵循**就近匹配**
> 2. 单个`Exp`可作为`Stmt`，它会被求值，所求的值被丢弃。
>
> #### `LVal`
>
> 1. 表示左值，可以为变量/某个数组元素
> 2. 当`LVal`表示数组时，方括号个数必须和数组变量的维数相同（即**定位到元素**）
> 3. 当`LVal`表示单个变量时，不能出现后面的方括号
>
> #### `Exp`和`Cond`
>
> 1. `Exp`代表`int`型表达式，其中不能出现单目运算符`!`或`< > <= >= != == && ||`
> 2. `Cond`代表条件表达式，可以出现各种运算符。非0表示真，0表示假。而关系运算或逻辑运算的结果用1表示真，0表示假。（个人理解，这是由于关系运算或逻辑运算的结果可能是后面算术运算的操作数）
> 3. `LVal`必须是当前作用域内，该`Exp`语句之前有定义的变量或常量；对于赋值号，左边的`LVal`必须是变量
> 4. 函数调用形式为`Ident '(' FuncRParams ')'`，其中的`FuncRParams`表示实参，其类型和个数必须与`Ident`对应的函数定义的形参完全匹配

## 符号表定义

在`SysY`中，共有3种类型的作用域：**全局(Global)**作用域、**函数形参(Formal)**作用域、**局部(Local)**作用域，各作用域对应符号表以及附属结构如下所示。

1. **Global**作用域符号表

| 名字: char* | 类别: bool | 返回类型: bool | 附加类型: union                                      | 函数形参域: FormalScope        | 函数体域: LocalScope           |
| ----------- | ---------- | -------------- | ---------------------------------------------------- | ------------------------------ | ------------------------------ |
| name        | isFunction | isVoid         | variable: ArrayInfo<br />function: 存储形参个数(int) | func: pointer<br />other: null | func: pointer<br />other: null |

2. 数组信息使用一个结构`ArrayInfo`表示，单独封装。

3. 函数**Formal**作用域符号表

| 形参名字: char* | 形参类型: bool | 数组信息: ArrayInfo |
| --------------- | -------------- | ------------------- |
| @+name          | isArray        | array_info          |

4. 函数体/语句块**Local**作用域符号表

由于文法的限制，`isArray`和`isConst`只能在不同阶段获取。

常量定义时，添加**name/isArray/ArrayInfo**信息（注意`int`类型的初值也存在`ArrayInfo`中），处理到`ConstDecl`/`VarDecl`时，为其添加`isConst`信息。

| 名字: char* | 是否常量: bool | 是否数组: bool | 是否Block: bool | 附加信息: ArrayInfo* | 内嵌域列表: LocalScope*                |
| ----------- | -------------- | -------------- | --------------- | -------------------- | -------------------------------------- |
| name        | isConst        | isArray        | isBlock         | 数组初始值           | **Block**: pointer<br />Other: nullptr |

遇到内嵌域（比如`for`循环里的`Block`）时，类别置为`Block`，内嵌列表指针指向子作用域符号表。



### 数组维度及初值的存储

待补充

### 库函数调用的处理

- 词法分析时单独处理函数名
- 在初始化Global符号表时，插入库函数对应信息